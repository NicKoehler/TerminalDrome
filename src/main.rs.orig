// I
use ratatui::style::Color;
use std::sync::Arc;
use std::{
    error::Error,
    fs,
    io,
    path::Path,
    process::{Child, Command},
    time::{Duration, Instant},
};

use anyhow::Result;
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    backend::CrosstermBackend,
    layout::{Constraint, Layout, Rect},
    style::{Modifier, Style},
    widgets::{Block, Borders, List, ListItem, Paragraph},
    Frame, Terminal,
};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use tempfile;
use tokio::{
    io::{AsyncBufReadExt, AsyncWriteExt, BufReader},
    net::UnixStream,
    sync::Mutex,
};

#[derive(Debug, Deserialize, Clone)]
struct Config {
    server: ServerConfig,
}

#[derive(Debug, Deserialize, Clone)]
struct ServerConfig {
    url: String,
    username: String,
    password: String,
}

#[derive(Debug, Deserialize)]
struct SubsonicResponse {
    #[serde(rename = "subsonic-response")]
    response: SubsonicContent,
}

#[derive(Debug, Deserialize)]
struct SubsonicContent {
    #[serde(flatten)]
    content: ContentType,
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum ContentType {
    Artists { artists: ArtistList },
    Albums { artist: ArtistDetail },
    Songs { album: AlbumDetail },
    Directory(MusicDirectory),
}

#[derive(Debug, Deserialize)]
struct ArtistList {
    index: Vec<ArtistGroup>,
}

#[derive(Debug, Deserialize)]
struct ArtistGroup {
    #[serde(default)]
    artist: Vec<Artist>,
}

#[derive(Debug, Deserialize, Clone, Serialize)]
struct Artist {
    id: String,
    name: String,
}

#[derive(Debug, Deserialize)]
struct ArtistDetail {
    album: Vec<Album>,
}

#[derive(Debug, Deserialize, Clone, Serialize)]
struct Album {
    id: String,
    name: String,
    artist: String,
    year: Option<i32>,
    songCount: u32,
}

#[derive(Debug, Deserialize)]
struct AlbumDetail {
    song: Vec<Song>,
}

#[derive(Debug, Deserialize, Clone, Serialize)]
struct Song {
    id: String,
    title: String,
    duration: u64,
    track: Option<u32>,
}

#[derive(Debug, Deserialize)]
struct MusicDirectory {
    child: Vec<Song>,
}

#[derive(Debug, PartialEq, Clone, Copy, Serialize, Deserialize)]
enum ViewMode {
    Artists,
    Albums,
    Songs,
}

#[derive(Debug, Default, Serialize, Deserialize, Clone, Copy)]
struct PanelState {
    selected: usize,
    scroll: usize,
}

#[derive(Debug, Serialize, Deserialize)]
struct AppState {
    mode: ViewMode,
    artist_state: PanelState,
    album_state: PanelState,
    song_state: PanelState,
    current_artist: Option<Artist>,
    current_album: Option<Album>,
    now_playing: Option<usize>,
}

impl Default for AppState {
    fn default() -> Self {
        Self {
            mode: ViewMode::Artists,
            artist_state: PanelState::default(),
            album_state: PanelState::default(),
            song_state: PanelState::default(),
            current_artist: None,
            current_album: None,
            now_playing: None,
        }
    }
}

struct App {
    artists: Vec<Artist>,
    albums: Vec<Album>,
    songs: Vec<Song>,
    mode: ViewMode,
    should_quit: bool,
    current_player: Option<Child>,
    status_message: String,
    current_artist: Option<Artist>,
    current_album: Option<Album>,
    artist_state: PanelState,
    album_state: PanelState,
    song_state: PanelState,
    now_playing: Option<usize>,
    player_status: Arc<Mutex<PlayerStatus>>,
    temp_dir: Option<tempfile::TempDir>,
}

#[derive(Default)]
struct PlayerStatus {
    current_index: Option<usize>,
    should_quit: bool,
}

impl Drop for App {
    fn drop(&mut self) {
        if let Some(mut player) = self.current_player.take() {
            let _ = player.kill();
        }
        if let Some(temp_dir) = &self.temp_dir {
            let _ = fs::remove_dir_all(temp_dir.path());
        }
    }
}

impl App {
    async fn new() -> Result<Self> {
        let config = read_config()?;
        let artists = get_artists(&config).await?;
        
        let loaded_state = Self::load_state().unwrap_or_default();
        
        let mut app = Self {
            artists,
            albums: Vec::new(),
            songs: Vec::new(),
            mode: loaded_state.mode,
            should_quit: false,
            current_player: None,
            status_message: String::new(),
            current_artist: loaded_state.current_artist.clone(),
            current_album: loaded_state.current_album.clone(),
            artist_state: loaded_state.artist_state,
            album_state: loaded_state.album_state,
            song_state: loaded_state.song_state,
            now_playing: loaded_state.now_playing,
            player_status: Arc::new(Mutex::new(PlayerStatus::default())),
            temp_dir: None,
        };

        if let Some(artist) = &app.current_artist {
            app.albums = get_artist_albums(&artist.id, &config).await?;
        }
        if let Some(album) = &app.current_album {
            app.songs = get_album_songs(&album.id, &config).await?;
        }

        Ok(app)
    }

    fn save_state(&self) -> Result<()> {
        let state = AppState {
            mode: self.mode,
            artist_state: self.artist_state,
            album_state: self.album_state,
            song_state: self.song_state,
            current_artist: self.current_artist.clone(),
            current_album: self.current_album.clone(),
            now_playing: self.now_playing,
        };

        let state_json = serde_json::to_string(&state)?;
        fs::write("state.json", state_json)?;
        Ok(())
    }

    fn load_state() -> Result<AppState> {
        if Path::new("state.json").exists() {
            let state_json = fs::read_to_string("state.json")?;
            Ok(serde_json::from_str(&state_json)?)
        } else {
            Ok(AppState::default())
        }
    }

    fn current_state_mut(&mut self) -> &mut PanelState {
        match self.mode {
            ViewMode::Artists => &mut self.artist_state,
            ViewMode::Albums => &mut self.album_state,
            ViewMode::Songs => &mut self.song_state,
        }
    }

    fn on_up(&mut self) {
        let state = self.current_state_mut();
        if state.selected > 0 {
            state.selected -= 1;
        }
        self.adjust_scroll();
    }

    fn on_down(&mut self) {
        let max_index = match self.mode {
            ViewMode::Artists => self.artists.len().saturating_sub(1),
            ViewMode::Albums => self.albums.len().saturating_sub(1),
            ViewMode::Songs => self.songs.len().saturating_sub(1),
        };
        
        let state = self.current_state_mut();
        if state.selected < max_index {
            state.selected += 1;
        }
        self.adjust_scroll();
    }

    fn adjust_scroll(&mut self) {
        let state = self.current_state_mut();
        let visible_items = 15;
        if state.selected < state.scroll {
            state.scroll = state.selected;
        } else if state.selected >= state.scroll + visible_items {
            state.scroll = state.selected - visible_items + 1;
        }
    }

    async fn load_albums(&mut self, config: &Config) -> Result<()> {
        self.albums.clear();
        self.current_album = None;
        self.songs.clear();
        self.now_playing = None;
        
        if let Some(artist) = self.artists.get(self.artist_state.selected) {
            self.albums = get_artist_albums(&artist.id, config).await?;
            self.current_artist = Some(artist.clone());
            self.mode = ViewMode::Albums;
        }
        Ok(())
    }

    async fn load_songs(&mut self, config: &Config) -> Result<()> {
        self.songs.clear();
        self.now_playing = None;
        
        if let Some(album) = self.albums.get(self.album_state.selected) {
            self.songs = get_album_songs(&album.id, config).await?;
            self.current_album = Some(album.clone());
            self.mode = ViewMode::Songs;
            
            self.song_state.selected = 0;
            self.adjust_scroll();
            
            self.start_playback(config).await?;
        }
        Ok(())
    }
    
// II

async fn start_playback(&mut self, config: &Config) -> Result<()> {
    if let Some(mut player) = self.current_player.take() {
        let _ = player.kill();
    }

    let start_index = self.song_state.selected;
    let status = self.player_status.clone();
    let temp_dir = tempfile::tempdir()?;
    let socket_path = temp_dir.path().join("mpv.sock");
    let socket_path_str = socket_path.to_str().unwrap();

    self.temp_dir = Some(temp_dir);
    self.now_playing = Some(start_index);

    let mut command = Command::new("mpv");
    command
        .arg("--no-video")
        .arg(format!("--playlist-start={}", start_index))
        .arg("--really-quiet")
        .arg("--no-terminal")
        .arg("--audio-display=no")
        .arg("--msg-level=all=error")
        .arg(format!("--input-ipc-server={}", socket_path_str));

    for song in &self.songs {
        let url = format!(
            "{}/rest/stream?id={}&u={}&p={}&v=1.16.1&c=TerminalDrome&f=json",
            config.server.url, 
            song.id, 
            config.server.username, 
            config.server.password
        );
        command.arg(url);
    }

    match command.spawn() {
        Ok(child) => {
            self.current_player = Some(child);
            let album_name = self.current_album.as_ref().map(|a| &a.name).unwrap_or("");
            self.status_message = format!("Playing: {}", album_name);
            
            let status_clone = status.clone();
            let socket_path_clone = socket_path_str.to_string();
            
            tokio::spawn(async move {
                let mut buffer = String::new();
                loop {
                    match UnixStream::connect(&socket_path_clone).await {
                        Ok(mut stream) => {
                            let observe_cmd = serde_json::json!({
                                "command": ["observe_property", 1, "playlist-pos"]
                            });
                            
                            stream.write_all(observe_cmd.to_string().as_bytes()).await.ok();
                            stream.write_all(b"\n").await.ok();

                            let mut reader = BufReader::new(stream);
                            while reader.read_line(&mut buffer).await.is_ok() {
                                match serde_json::from_str::<Value>(&buffer) {
                                    Ok(event) => {
                                    if let (Some(Value::String(name)), Some(Value::Number(n))) = (
                                        event.get("name"),
                                        event.get("data")   // <- Korrigiert zu "data"
                                    ) {
                                        if name == "playlist-pos" {
                                            if let Some(index) = n.as_i64() {
                                                let mut status = status_clone.lock().await;
                                                status.current_index = Some(index as usize);
                                            }
                                        }
                                    }
                                }
                                buffer.clear();
                            }
                        },
                        Err(e) => eprintln!("Failed to parse event: {}", e),
                    }
                    
                    if status_clone.lock().await.should_quit {
                        break;
                    }
                }
            });
        }
        Err(e) => self.status_message = format!("Error: {}", e),
    }
    Ok(())
}

async fn stop_playback(&mut self) {
    if let Some(mut player) = self.current_player.take() {
        let _ = player.kill();
        self.status_message = "Stopped".to_string();
        self.now_playing = None;
        
        let mut status = self.player_status.lock().await;
        status.current_index = None;
        status.should_quit = true;
    }
}

async fn update_now_playing(&mut self) {
    let current_index = self.player_status.lock().await.current_index;
    if let Some(index) = current_index {
        let valid_index = index.min(self.songs.len().saturating_sub(1));
        if self.now_playing != Some(valid_index) {
            self.now_playing = Some(valid_index);
            self.song_state.selected = valid_index;
            self.adjust_scroll();
        }
    }
}

fn get_now_playing_info(&self) -> String {
    self.now_playing
        .and_then(|i| self.songs.get(i))
        .map(|song| {
            let (min, sec) = (song.duration / 60, song.duration % 60);
            let album = self.current_album.as_ref().map(|a| &a.name).map_or("", |v| v);
            let artist = self.current_artist.as_ref().map(|a| &a.name).map_or("", |v| v);
            format!("▶️ {} - {} ({:02}:{:02})", artist, song.title, min, sec)
        })
        .unwrap_or_else(|| "⏹ No song playing".into())
}
}

impl ViewMode {
fn previous(&self) -> Self {
    match self {
        ViewMode::Songs => ViewMode::Albums,
        ViewMode::Albums => ViewMode::Artists,
        _ => ViewMode::Artists,
    }
}
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
enable_raw_mode()?;
let mut stdout = io::stdout();
execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
let backend = CrosstermBackend::new(stdout);
let mut terminal = Terminal::new(backend)?;

let mut app = App::new().await?;
let mut last_tick = Instant::now();

loop {
    app.update_now_playing().await;
    terminal.draw(|f| ui(f, &app))?; // Dann rendern


    if event::poll(Duration::from_millis(50))? {
        if let Event::Key(key) = event::read()? {
            if key.kind == KeyEventKind::Press {
                match key.code {
                    KeyCode::Char('q') => {
                        app.stop_playback().await;
                        break;
                    }
                    KeyCode::Up => app.on_up(),
                    KeyCode::Down => app.on_down(),
                    KeyCode::Left => app.mode = app.mode.previous(),
                    KeyCode::Right | KeyCode::Enter => {
                        let config = read_config()?;
                        match app.mode {
                            ViewMode::Artists => app.load_albums(&config).await?,
                            ViewMode::Albums => app.load_songs(&config).await?,
                            ViewMode::Songs => app.start_playback(&config).await?,
                        }
                    }
                    KeyCode::Char(' ') => app.stop_playback().await,
                    _ => {}
                }
            }
        }
    }

    if last_tick.elapsed() > Duration::from_millis(100) {
        last_tick = Instant::now();
    }
}

disable_raw_mode()?;
execute!(terminal.backend_mut(), LeaveAlternateScreen, DisableMouseCapture)?;
terminal.show_cursor()?;
Ok(())
}

fn ui(frame: &mut Frame, app: &App) {
let main_layout = Layout::vertical([
    Constraint::Min(3),
    Constraint::Length(3),
]).split(frame.size());

let panels = Layout::horizontal([
    Constraint::Ratio(1, 3),
    Constraint::Ratio(1, 3),
    Constraint::Ratio(1, 3),
]).split(main_layout[0]);

render_artists_panel(frame, app, panels[0]);
render_albums_panel(frame, app, panels[1]);
render_songs_panel(frame, app, panels[2]);

let status_bar = Layout::vertical([
    Constraint::Length(1),
    Constraint::Length(1),
]).split(main_layout[1]);

let status_block = Paragraph::new(app.status_message.clone())
    .style(Style::default().fg(Color::Black).bg(Color::DarkGray))
    .block(Block::default().borders(Borders::TOP));
frame.render_widget(status_block, status_bar[0]);

let now_playing = Paragraph::new(app.get_now_playing_info())
    .style(Style::default().fg(Color::Yellow).bg(Color::DarkGray));
frame.render_widget(now_playing, status_bar[1]);
}

fn render_artists_panel(frame: &mut Frame, app: &App, area: Rect) {
let title = format!(" Artists ({}) ", app.artists.len());
let block = Block::default()
    .title(title)
    .borders(Borders::ALL)
    .border_style(if app.current_artist.is_some() {
        Style::default().fg(Color::LightCyan)
    } else {
        Style::default().fg(Color::Gray)
    });

let items: Vec<ListItem> = app.artists
    .iter()
    .skip(app.artist_state.scroll)
    .take(area.height as usize - 2)
    .enumerate()
    .map(|(i, artist)| {
        let is_selected = app.artist_state.selected == i + app.artist_state.scroll;
        let style = if is_selected {
            Style::default().fg(Color::Blue)
        } else {
            Style::default().fg(Color::Gray)
        };
        ListItem::new(artist.name.clone()).style(style)
    })
    .collect();

frame.render_widget(List::new(items).block(block), area);
}

fn render_albums_panel(frame: &mut Frame, app: &App, area: Rect) {
    let title = format!(" Albums ({}) ", app.albums.len());
    let block = Block::default()
        .title(title)
        .borders(Borders::ALL)
        .border_style(if app.current_album.is_some() {
            Style::default().fg(Color::LightCyan)
        } else {
            Style::default().fg(Color::Gray)
        });

    let items: Vec<ListItem> = app.albums
        .iter()
        .skip(app.album_state.scroll)
        .take(area.height as usize - 2)
        .enumerate()
        .map(|(i, album)| {
            let is_selected = app.album_state.selected == i + app.album_state.scroll;
            let is_active = app.current_album.as_ref().map(|a| a.id.as_str()) == Some(album.id.as_str());
            
            let style = if is_active {
                Style::default()
                    .fg(Color::Blue)
                    .add_modifier(Modifier::BOLD)
            } else if is_selected {
                Style::default().fg(Color::Blue)
            } else {
                Style::default().fg(Color::Gray)
            };

            let text = format!("{} ({})", album.name, album.year.unwrap_or(0));
            ListItem::new(text).style(style)
        })
        .collect();

    frame.render_widget(List::new(items).block(block), area);
}

fn render_songs_panel(frame: &mut Frame, app: &App, area: Rect) {
    let title = match &app.current_album {
        Some(album) => format!(" {} ({}) ", album.name, app.songs.len()),
        None => " Songs ".to_string(),
    };

    let block = Block::default()
        .title(title)
        .borders(Borders::ALL)
        .border_style(Style::default().fg(Color::Gray));

    let items: Vec<ListItem> = app.songs
        .iter()
        .skip(app.song_state.scroll)
        .take(area.height as usize - 2)
        .enumerate()
        .map(|(i, song)| {
            let absolute_index = i + app.song_state.scroll;
            let is_selected = app.song_state.selected == absolute_index;
            let is_playing = app.now_playing == Some(absolute_index);

            let style = if is_playing {
                Style::default()
                    .fg(Color::Yellow)
                    .add_modifier(Modifier::BOLD)
            } else if is_selected {
                Style::default().fg(Color::Blue)
            } else {
                Style::default().fg(Color::Gray)
            };

            let minutes = song.duration / 60;
            let seconds = song.duration % 60;
            let text = format!("{:02}:{:02} - {}", minutes, seconds, song.title);
            ListItem::new(text).style(style)
        })
        .collect();

    frame.render_widget(List::new(items).block(block), area);
}

async fn get_artists(config: &Config) -> Result<Vec<Artist>> {
let client = reqwest::Client::new();
let response = client
    .get(format!("{}/rest/getArtists", config.server.url))
    .query(&[
        ("u", config.server.username.as_str()),
        ("p", config.server.password.as_str()),
        ("v", "1.16.1"),
        ("c", "TerminalDrome"),
        ("f", "json"),
    ])
    .send()
    .await?;

let body = response.text().await?;
let parsed: SubsonicResponse = serde_json::from_str(&body)?;

match parsed.response.content {
    ContentType::Artists { artists } => Ok(artists.index.into_iter().flat_map(|g| g.artist).collect()),
    _ => anyhow::bail!("Unexpected response format"),
}
}

async fn get_artist_albums(artist_id: &str, config: &Config) -> Result<Vec<Album>> {
    let client = reqwest::Client::new();
    let response = client
        .get(format!("{}/rest/getArtist", config.server.url))
        .query(&[
            ("u", config.server.username.as_str()),
            ("p", config.server.password.as_str()),
            ("v", "1.16.1"),
            ("c", "TerminalDrome"),
            ("f", "json"),
            ("id", artist_id),
        ])
        .send()
        .await?;

    let body = response.text().await?;
    let parsed: SubsonicResponse = serde_json::from_str(&body)?;

    match parsed.response.content {
        ContentType::Albums { artist } => Ok(artist.album),
        _ => anyhow::bail!("Unexpected response format for artist albums"),
    }
}

async fn get_album_songs(album_id: &str, config: &Config) -> Result<Vec<Song>> {
    let client = reqwest::Client::new();
    let response = client
        .get(format!("{}/rest/getAlbum", config.server.url))
        .query(&[
            ("u", config.server.username.as_str()),
            ("p", config.server.password.as_str()),
            ("v", "1.16.1"),
            ("c", "TerminalDrome"),
            ("f", "json"),
            ("id", album_id),
        ])
        .send()
        .await?;

    let body = response.text().await?;
    let parsed: SubsonicResponse = serde_json::from_str(&body)?;

    match parsed.response.content {
        ContentType::Songs { album } => Ok(album.song),
        _ => anyhow::bail!("Unexpected response format for album songs"),
    }
}
fn read_config() -> Result<Config> {
let config = fs::read_to_string("config.toml")?;
Ok(toml::from_str(&config)?)
}